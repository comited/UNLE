/*function spaceEdgesOnNode() {
            for (var i = 0; i < nodesEdgeNum.length; i++) {
                if (nodesEdgeNum[i] <= 1)
                    continue;

                const angle = 360 / (nodesEdgeNum[i]);

                var angles = Array(nodesEdgeNum[i]);

                for (var j = 0; j < nodesEdgeNum[i]; j++) {
                    angles[j] = angle * j;
                }

                var connectedNodes = []
                for (var k = 0; k < testEdges.length; k++) {
                    if (testEdges[k][0] == i && testEdges[k][1] != i) {
                        connectedNodes.push([testEdges[k][1], testEdges[k][2]])
                    } else if (testEdges[k][1] == i && testEdges[k][0] != i) {
                        connectedNodes.push([testEdges[k][0], testEdges[k][2]])
                    }
                }

                var currentAngles = new Array(connectedNodes.length).fill([0, 0]);

                for (var j = 0; j < connectedNodes.length; j++) {
                    var dx = NodesContainer.children[i].x - NodesContainer.children[connectedNodes[j][0]].x;
                    var dy = NodesContainer.children[i].y - NodesContainer.children[connectedNodes[j][0]].y;
                    var deg = (Math.atan2(dx, dy) * (180 / Math.PI) + 360) % 360;
                    currentAngles[j] = [deg, j]
                }

                // sort the angles from smallest to largest
                currentAngles.sort(function(a, b){return a[0] - b[0]});
                console.log(currentAngles)
                // currentAngles[j] = [deg, index]
                console.log(i)
                console.log(currentAngles.length)
                for (var j = 0; j < currentAngles.length; j++) {
                    const idx = currentAngles[j][1];
                    var dist = connectedNodes[idx][1];

                    //console.log(`Current angle: ${currentAngles[j][0]} Target angle: ${angles[j]} idx: ${connectedNodes[idx][0]}`)
                    
                    var offsetX = dist * Math.sin(-toRadians(90)) / constant;
                    var offsetY = dist * Math.cos(-toRadians(90)) / constant;

                    //console.log(`${offsetX} : ${offsetY}`)

                    // move the node towards the position
                    NodesContainer.children[connectedNodes[idx][0]].x -= offsetX;
                    NodesContainer.children[connectedNodes[idx][0]].y -= offsetY;

                    // now move the current node in the opposite angle to the position
                    //NodesContainer.children[i].x += offsetX;
                    //NodesContainer.children[i].y += offsetY;
                }
                
            }
        }*/

        /*for (var j = 0; j < connectedNodes.length; j++) {
                    var dist = connectedNodes[j][1];
                    
                    var offsetX = (dist) * Math.sin(toRadians(angles[j])) / constant;
                    var offsetY = (dist) * Math.cos(toRadians(angles[j])) / constant;

                    // move the node towards the position
                    NodesContainer.children[connectedNodes[j][0]].x += offsetX;
                    NodesContainer.children[connectedNodes[j][0]].y += offsetY;

                    // now move the current node in the opposite angle to the position
                    NodesContainer.children[i].x -= offsetX;
                    NodesContainer.children[i].y -= offsetY;
                }*/