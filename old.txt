/*function spaceEdgesOnNode() {
            for (var i = 0; i < nodesEdgeNum.length; i++) {
                if (nodesEdgeNum[i] <= 1)
                    continue;

                const angle = 360 / (nodesEdgeNum[i]);

                var angles = Array(nodesEdgeNum[i]);

                for (var j = 0; j < nodesEdgeNum[i]; j++) {
                    angles[j] = angle * j;
                }

                var connectedNodes = []
                for (var k = 0; k < testEdges.length; k++) {
                    if (testEdges[k][0] == i && testEdges[k][1] != i) {
                        connectedNodes.push([testEdges[k][1], testEdges[k][2]])
                    } else if (testEdges[k][1] == i && testEdges[k][0] != i) {
                        connectedNodes.push([testEdges[k][0], testEdges[k][2]])
                    }
                }

                var currentAngles = new Array(connectedNodes.length).fill([0, 0]);

                for (var j = 0; j < connectedNodes.length; j++) {
                    var dx = NodesContainer.children[i].x - NodesContainer.children[connectedNodes[j][0]].x;
                    var dy = NodesContainer.children[i].y - NodesContainer.children[connectedNodes[j][0]].y;
                    var deg = (Math.atan2(dx, dy) * (180 / Math.PI) + 360) % 360;
                    currentAngles[j] = [deg, j]
                }

                // sort the angles from smallest to largest
                currentAngles.sort(function(a, b){return a[0] - b[0]});
                console.log(currentAngles)
                // currentAngles[j] = [deg, index]
                console.log(i)
                console.log(currentAngles.length)
                for (var j = 0; j < currentAngles.length; j++) {
                    const idx = currentAngles[j][1];
                    var dist = connectedNodes[idx][1];

                    //console.log(`Current angle: ${currentAngles[j][0]} Target angle: ${angles[j]} idx: ${connectedNodes[idx][0]}`)
                    
                    var offsetX = dist * Math.sin(-toRadians(90)) / constant;
                    var offsetY = dist * Math.cos(-toRadians(90)) / constant;

                    //console.log(`${offsetX} : ${offsetY}`)

                    // move the node towards the position
                    NodesContainer.children[connectedNodes[idx][0]].x -= offsetX;
                    NodesContainer.children[connectedNodes[idx][0]].y -= offsetY;

                    // now move the current node in the opposite angle to the position
                    //NodesContainer.children[i].x += offsetX;
                    //NodesContainer.children[i].y += offsetY;
                }
                
            }
        }*/

        /*for (var j = 0; j < connectedNodes.length; j++) {
                    var dist = connectedNodes[j][1];
                    
                    var offsetX = (dist) * Math.sin(toRadians(angles[j])) / constant;
                    var offsetY = (dist) * Math.cos(toRadians(angles[j])) / constant;

                    // move the node towards the position
                    NodesContainer.children[connectedNodes[j][0]].x += offsetX;
                    NodesContainer.children[connectedNodes[j][0]].y += offsetY;

                    // now move the current node in the opposite angle to the position
                    NodesContainer.children[i].x -= offsetX;
                    NodesContainer.children[i].y -= offsetY;
                }*/


// get the other nodes that are connected to this node
for (var j = 1; j < connectedNodes.length - 1; j++) {
    const differenceBetweenConnectedNodes = 360 / (connectedNodes.length);

    // get the connected node
    var connectedNode = connectedNodes[j][0] == i ? connectedNodes[j][1] : connectedNodes[j][0];
    // get the next connected node if it exists
    var nextConnectedNode = connectedNodes[j+1][0] == i ? connectedNodes[j+1][1] : connectedNodes[j+1][0];

    // get the angle between connectedNode and nextConnectedNode
    var dx = NodesContainer.children[nextConnectedNode].x - NodesContainer.children[connectedNode].x;
    var dy = NodesContainer.children[nextConnectedNode].y - NodesContainer.children[connectedNode].y;
    var angle = (Math.atan2(dx, dy) * (180 / Math.PI) + 360) % 360;

    // determine if connectedNode or nextConnectedNode should be moved clockwise or anti-clockwise
    var clockwise = angle > differenceBetweenConnectedNodes ? true : false;

    // move the connectedNode
    var offsetX, nextOffsetX = 0;
    var offsetY, nextOffsetY = 0;

    if (clockwise) {
        offsetX = Math.cos(angle) * 1;
        offsetY = Math.sin(angle) * 1;
        nextOffsetX = Math.cos(angle) * -1;
        nextOffsetY = Math.sin(angle) * -1;
    } else {
        offsetX = Math.cos(angle) * -1;
        offsetY = Math.sin(angle) * -1;
        nextOffsetX = Math.cos(angle) * 1;
        nextOffsetY = Math.sin(angle) * 1;
    }

    NodesContainer.children[connectedNode].x += offsetX;
    NodesContainer.children[connectedNode].y += offsetY;

    NodesContainer.children[nextConnectedNode].x += nextOffsetX;
    NodesContainer.children[nextConnectedNode].y += nextOffsetY;
}